set textwidth=100
cyder is an [IPAM][ipam] system. It is split up into two logically separate apps; `cydns` (DNS) and
`cydhcp` (DHCP). The goal is two have the two apps be standalone and have less generic code 'glue'
them together.

The 'glue' (not to be confused with DNS glue records) is found in `core/`.

Coding Ideas (Standards)
------------------------



Models shouldn't do anything magical. If something goes wrong, the calling code should be able to
tell exactly what went wrong. Exceptions should be used at the model level and in helper function
level. Ideally, these exceptions can help the code that more directly interfaces with the user to
make CRUD tasks easier.

Avoid touching the models. You should never ever *EVER* directly create or update an instance of a
model. Use helper function and use them everywhere. If a helper function doesn't exist *CREATE* it
instead of directly accessing the model. Accessing the models for read access is OK.

Builder function for models should be in the models.py file of the model. For more complex tasks
don't be afraid to use a different utility (not named utility!!) module.

No trailing white space anywhere.

Test everything (try to).

Before you do anything with an IP address (as a string or int) put it into the ipaddr library
functions IPv4Address and IPv6Address. This will standardise how things are formated, stored, and
displayed.

DNS
===
Domains and Reverse Domains
---------------------------
Domains and Reverse Domains are at the core of the DNS app. They are traversed during the build
process and will allow individual zones files to be built. There are some core ideas that are
helpful to understand about how these two objects are implemented. A solid understanding of DNS is
assumed.

### Reverse Domains

Consider the reverse domain 20.193.128.in-addr.arpa. It is stored as a VAR CHAR in the database and
is represented as

    128.193.20

(The in-addr.arpa cruft is only added during build time).

Both Domains and Reverse Domains should be thought of as a tree data structure. So for our example,

    128
    |
    130
    |
    20

If we added 21.193.128.in-addr.arpa it would look like.

    128
    |
    130
    |  \
    20  21

The database would have the records.

    id  name        master_reverse_domain   SOA

    1   128         Null                    Null
    2   128.193     1                       1 <--- the SOA table is not shown here
    3   128.193.20  2                       1
    4   128.193.21  2                       1

The reverse domain `128` is in the database even though we do not have an SOA for it. Keeping a
complete tree in the database is (in my mind) a good idea. It also allows adding new reverse domains
an un-ambigous process. But what does this mean? You can't add `193.128.in-addr.arpa` without adding
`128.in-addr.arpa`. This is find for Ipv4 reverse domains, but what about Ipv6 reverse domains? They
are very long and it would be tedious to add them one by one. TODO there should be a function in
`cydns/reverse_domain/models.py` that aids in the bootstrapping process of creating Ipv6 reverse
domains.

### Domains

Domains are very similar to reverse domains. Consider foo.bar.oregonstate.edu. The tree would look
like:

    edu
    |
    oregonstate
    |       \
    foo     bar

The database would have the records.

    id  name                    master_domain   SOA

    1   edu                     Null            Null
    2   oregonstate.edu         1               1 <--- the SOA table is not shown here
    3   foo.oregonstate.edu     2               1
    4   bar.oregonstate.edu     2               1

Note the `edu` domain. It's in the database even though we are not SOA for that domain. And just as
it was with reverse domains, you should not be able to add foo.oregonstate.edu without adding
oregonstate.edu first. Fortunatly, boot strapping domains should not be an issue for plain Domains.

### Why a full tree?
I for see the question "Why do you have the edu domain in the database? You aren't authoritative for
that domain!". I also asked myself that question, and the answer I came up with is "It makes things
more complete". It also removes any ambiguity when searching for a master domain for a new domain
being added. Here is an example.

Say we want to add cute.cat.com. Let's say we are *not* keeping a complete tree in the DB and this
is the first domain we added. It's master domain would be `Null`.

    id  name                    master_domain   SOA

    1   cute.cat.com            Null            1 <--- the SOA table is not show here

Let's now assume we are going to add cat.com. We don't have a `com` domain, so it's master domain is
`Null`.

    id  name                    master_domain   SOA

    1   cute.cat.com            Null            1
    2   cat.com                 Null            1

This obviously isn't correct. We need to search the domain table to change cute.cat.com's
master_domain to 2, cat.com's `id`.

    id  name                    master_domain   SOA

    1   cute.cat.com            2               1
    2   cat.com                 Null            1

We still have to keep the tree complete. Now consider if we had to create all domains before we add a
domain. When we add cute.cat.com:

    id  name                    master_domain   SOA

    1   com                     Null            Null
    2   cat.com                 1               Null
    3   cute.cat.com            2               1

When we acquire cat.com, all we need to do is change the SOA field!

    id  name                    master_domain   SOA

    1   com                     Null            Null
    2   cat.com                 1               1
    3   cute.cat.com            2               1

That's my attempt to justify.


Race Conditions
---------------
There are possible race conditions in adding and removing a reverse_domain.

reverse_domain: 128.193.8
reverse_domain: 128.193


    Someone starts to delete 128.193.8
    You create a new ip with reverse_domain = 128.193.8
    Before you do Ip.save(), 128.193.8 is deleted in the database.
    You do Ip.save()
    You now reverence a non existant reverse_domain.

Likely hood: Very Very low.
Solution: Lock the reverse_domain table when creating a new Ip or have a script go through once in a
while and make sure every ip has a valid reverse_domain. If it doesn't find the correct one and
assign it.

Reverse IPv6 Domains
--------------------
Problem

    1234::
    1234:0:0::
    1234:0:0:0::

These are valid reverse_domains. Can we use longest prefix match to determine their master_domain?
This is a tree insertion problem.


    1234:: [ip set: 1234:1:: 1234:2::]
    |
    1234:0:0:0:: [ip set: 1234:0:0:: 1234:0:1::]

(note that all reverse ipv6 domains have no trailing '::' in the db)

Let's now add 1234:0:0::

    1234:: [ip set: 1234:1:: 1234:2::]
    |
    1234:0:0:: [ip set: ?]
    |
    1234:0:0:0:: [ip set: 1234:0:0:0:1: 1234:0:0:0:2::]

What is it's ip set? Technically, both `1234:0:0::` and `1234:0:0:0::` should have `1234:0:0:0:1:`
and `1234:0:0:0:2::` in their reverse domain.

Using longest prefix matching.


    1234:: [ip set: 1234:1:: 1234:2::]
    |
    1234:0:0:: [ip set: Null ]
    |
    1234:0:0:0:: [ip set: 1234:0:0:0:1: 1234:0:0:0:2::]

If instead we started with:

    1234:: [ip set: 1234:1:: 1234:2::]
    |
    1234:0:0:: [ip set: 1234:0:0:0:1: 1234:0:0:0:2::]

Then we added, `1234:0:0:0::`,  the ip set would be reassigned and we would have the same tree.

    1234:: [ip set: 1234:1:: 1234:2::]
    |
    1234:0:0:: [ip set: Null ]
    |
    1234:0:0:0:: [ip set: 1234:0:0:0:1: 1234:0:0:0:2::]

### So what is the problem right now?

It comes down to the `ipaddr` library. The address `1234::` and `1234:0:0:0::`, when put into
IPv6Address come out to the same representation `1234::`.

Notes on setup
--------------

    virtualenv --no-site-packages cyder_env
    cd cyder_env
    source bin/activate
    sudo apt-get build-dep python-mysqldb
    pip install MySQL-python
    pip install ipaddr
    http://packages.python.org/ipaddr/

[ipam]:http://en.wikipedia.org/wiki/Internet_Protocol_Address_Management
