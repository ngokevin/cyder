set textwidth=100
cyder is an [IPAM][ipam] system. It is split up into two logically separate apps; `cydns` (DNS) and
`cydhcp` (DHCP). The goal is two have the two apps be standalone and have less generic code 'glue'
them together.

The 'glue' (not to be confused with DNS glue records) is found in `core/`.

Coding Ideas (Standards)
------------------------



Models shouldn't do anything magical. If something goes wrong, the calling code should be able to
tell exactly what went wrong. Exceptions should be used at the model level and in helper function
level. Ideally, these exceptions can help the code that more directly interfaces with the user to
make CRUD tasks easier.

Avoid touching the models. You should never ever *EVER* directly create or update an instance of a
model. Use helper function and use them everywhere. If a helper function doesn't exist *CREATE* it
instead of directly accessing the model. Accessing the models for read access is OK.

Builder function for models should be in the models.py file of the model. For more complex tasks
don't be afraid to use a different utility (not named utility!!) module.

No trailing white space anywhere.

Test everything (try to).

Before you do anything with an IP address (as a string or int) put it into the ipaddr library
functions IPv4Address and IPv6Address. This will standardise how things are formated, stored, and
displayed.



Race Conditions
---------------
There are possible race conditions in adding and removing a reverse_domain.

reverse_domain: 128.193.8
reverse_domain: 128.193


    Someone starts to delete 128.193.8
    You create a new ip with reverse_domain = 128.193.8
    Before you do Ip.save(), 128.193.8 is deleted in the database.
    You do Ip.save()
    You now reverence a non existant reverse_domain.

Likely hood: Very Very low.
Solution: Lock the reverse_domain table when creating a new Ip or have a script go through once in a
while and make sure every ip has a valid reverse_domain. If it doesn't find the correct one and
assign it.

Reverse IPv6 Domains
--------------------
Problem

    1234::
    1234:0:0::
    1234:0:0:0::

These are valid reverse_domains. Can we use longest prefix match to determine their master_domain?
This is a tree insertion problem.


    1234:: [ip set: 1234:1:: 1234:2::]
    |
    1234:0:0:0:: [ip set: 1234:0:0:: 1234:0:1::]

(note that all reverse ipv6 domains have no trailing '::' in the db)

Let's now add 1234:0:0::

    1234:: [ip set: 1234:1:: 1234:2::]
    |
    1234:0:0:: [ip set: ?]
    |
    1234:0:0:0:: [ip set: 1234:0:0:0:1: 1234:0:0:0:2::]

What is it's ip set? Technically, both `1234:0:0::` and `1234:0:0:0::` should have `1234:0:0:0:1:`
and `1234:0:0:0:2::` in their reverse domain.

Using longest prefix matching.


    1234:: [ip set: 1234:1:: 1234:2::]
    |
    1234:0:0:: [ip set: Null ]
    |
    1234:0:0:0:: [ip set: 1234:0:0:0:1: 1234:0:0:0:2::]

If instead we started with:

    1234:: [ip set: 1234:1:: 1234:2::]
    |
    1234:0:0:: [ip set: 1234:0:0:0:1: 1234:0:0:0:2::]

Then we added, `1234:0:0:0::`,  the ip set would be reassigned and we would have the same tree.

    1234:: [ip set: 1234:1:: 1234:2::]
    |
    1234:0:0:: [ip set: Null ]
    |
    1234:0:0:0:: [ip set: 1234:0:0:0:1: 1234:0:0:0:2::]

### So what is the problem right now?

It comes down to the `ipaddr` library. The address `1234::` and `1234:0:0:0::`, when put into
IPv6Address come out to the same representation `1234::`.

Notes on setup
--------------

    virtualenv --no-site-packages cyder_env
    cd cyder_env
    source bin/activate
    sudo apt-get build-dep python-mysqldb
    pip install MySQL-python
    pip install ipaddr
    http://packages.python.org/ipaddr/

[ipam]:http://en.wikipedia.org/wiki/Internet_Protocol_Address_Management
